# Анализ производительности приложения

## Текущее состояние

### Backend (Express.js + TypeORM + PostgreSQL)
- **Фреймворк**: Express.js 4.18.2
- **ORM**: TypeORM 0.3.17
- **База данных**: PostgreSQL
- **Деплой**: Railway (один инстанс)
- **Rate Limiting**: ❌ Отсутствует
- **Кэширование**: ❌ Отсутствует
- **Пул соединений БД**: Используются дефолтные настройки TypeORM (10 соединений)

### Frontend (Next.js)
- **Фреймворк**: Next.js 14.0.4
- **Деплой**: Vercel (Serverless Functions)
- **SSR**: Включен

## Оценка пропускной способности

### Текущие ограничения

#### 1. Backend (Railway)
**Оценка: 50-200 одновременных запросов**

Ограничения:
- **Один инстанс Node.js**: Express может обрабатывать ~1000-5000 запросов/сек на мощном сервере, но Railway на базовом плане ограничивает ресурсы
- **Пул соединений БД**: TypeORM по умолчанию использует 10 соединений. При превышении запросы будут ждать освобождения соединения
- **Память**: Railway на бесплатном/базовом плане предоставляет ограниченную память (обычно 512MB-1GB)
- **CPU**: Ограниченные ресурсы CPU на базовом плане Railway

**Реальные цифры:**
- Легкие запросы (GET /api/restaurants): ~100-200 req/s
- Средние запросы (GET /api/menu/:id): ~50-100 req/s
- Тяжелые запросы (POST /api/auth/telegram с созданием пользователя): ~20-50 req/s

#### 2. База данных (PostgreSQL на Railway)
**Оценка: 50-100 одновременных соединений**

Ограничения:
- Railway PostgreSQL на базовом плане обычно ограничивает до 100 одновременных соединений
- TypeORM пул из 10 соединений - это узкое место при высокой нагрузке
- Нет индексов на часто используемых полях (требуется проверка)

#### 3. Frontend (Vercel)
**Оценка: Практически неограниченно (Serverless)**

Vercel использует Serverless Functions, которые автоматически масштабируются:
- Каждый запрос обрабатывается отдельным инстансом
- Ограничение только по таймауту (10 секунд для Hobby плана)
- Может обрабатывать тысячи одновременных запросов

## Критические проблемы

### 1. ❌ Отсутствие Rate Limiting
**Риск**: Приложение уязвимо к DDoS атакам и злоупотреблению

**Последствия:**
- Один пользователь может отправить тысячи запросов и перегрузить сервер
- Возможна атака на эндпоинты аутентификации
- Исчерпание пула соединений БД

### 2. ⚠️ Неоптимальный пул соединений БД
**Проблема**: TypeORM использует дефолтные 10 соединений

**Последствия:**
- При 11+ одновременных запросах к БД один запрос будет ждать
- Увеличение времени отклика при высокой нагрузке

### 3. ⚠️ Отсутствие кэширования
**Проблема**: Каждый запрос идет в БД

**Последствия:**
- Избыточная нагрузка на БД для статических данных (меню, рестораны)
- Медленные ответы при повторных запросах

### 4. ⚠️ Нет мониторинга производительности
**Проблема**: Нет метрик для отслеживания производительности

**Последствия:**
- Невозможно определить узкие места
- Нет предупреждений о перегрузке

## Рекомендации по улучшению

### Приоритет 1: Критично (защита от падения)

#### 1. Добавить Rate Limiting
```bash
npm install express-rate-limit
```

**Ожидаемый эффект**: Защита от перегрузки, возможность обработать 100-200 req/s стабильно

#### 2. Настроить пул соединений БД
Увеличить пул до 20-30 соединений (в зависимости от лимитов Railway PostgreSQL)

**Ожидаемый эффект**: Увеличение пропускной способности до 200-300 одновременных запросов

#### 3. Добавить graceful degradation
При перегрузке возвращать 503 Service Unavailable вместо падения

**Ожидаемый эффект**: Приложение не падает, а корректно обрабатывает перегрузку

### Приоритет 2: Важно (улучшение производительности)

#### 4. Добавить кэширование для статических данных
- Redis для кэширования меню и ресторанов
- TTL: 5-15 минут для меню, 1 час для ресторанов

**Ожидаемый эффект**: Увеличение пропускной способности до 500-1000 req/s для кэшируемых эндпоинтов

#### 5. Оптимизировать запросы к БД
- Добавить индексы на часто используемые поля
- Использовать `select` для загрузки только нужных полей
- Избегать N+1 запросов

**Ожидаемый эффект**: Уменьшение времени ответа на 30-50%

#### 6. Добавить мониторинг
- Логирование времени выполнения запросов
- Метрики через Prometheus или аналоги
- Алерты при превышении порогов

### Приоритет 3: Желательно (масштабирование)

#### 7. Горизонтальное масштабирование
- Запуск нескольких инстансов через PM2 или Railway scaling
- Использование load balancer

**Ожидаемый эффект**: Линейное увеличение пропускной способности (2 инстанса = 2x производительность)

#### 8. Оптимизация базы данных
- Connection pooling на уровне БД (PgBouncer)
- Репликация для чтения
- Партиционирование больших таблиц

## Итоговая оценка пропускной способности

### Текущее состояние (без оптимизаций)
- **Одновременных запросов**: 50-100
- **Запросов в секунду**: 50-200 req/s
- **Риск падения**: Высокий при нагрузке >100 одновременных запросов

### После оптимизаций Приоритета 1
- **Одновременных запросов**: 200-300
- **Запросов в секунду**: 200-400 req/s
- **Риск падения**: Средний при нагрузке >300 одновременных запросов

### После всех оптимизаций
- **Одновременных запросов**: 500-1000+
- **Запросов в секунду**: 1000-2000+ req/s (для кэшируемых эндпоинтов)
- **Риск падения**: Низкий при правильной настройке

## Конкретные проблемы в коде

### Отсутствие индексов в БД

#### 1. Restaurant.isActive
**Проблема**: В `restaurants.ts` запрос фильтрует по `isActive: true`, но нет индекса
```typescript
// Текущий код делает полное сканирование таблицы
const restaurants = await restaurantRepository.find({
  where: { isActive: true },
});
```

**Решение**: Добавить индекс
```typescript
@Column({ default: true })
@Index()
isActive!: boolean;
```

#### 2. MenuItem.restaurantId и MenuItem.isAvailable
**Проблема**: В `menu.ts` запрос фильтрует по `restaurantId` и `isAvailable`, но нет составного индекса
```typescript
// Текущий код может быть медленным при большом количестве меню
const menuItems = await menuItemRepository.find({
  where: { restaurantId, isAvailable: true },
});
```

**Решение**: Добавить составной индекс
```typescript
@Entity('menu_items')
@Index(['restaurantId', 'isAvailable'])
export class MenuItem {
  // ...
}
```

**Ожидаемый эффект**: Ускорение запросов меню на 50-90% при большом количестве записей

## Выводы

**Текущая пропускная способность: 50-100 одновременных запросов**

Приложение может обработать умеренную нагрузку, но уязвимо к:
- Внезапным всплескам трафика
- DDoS атакам (нет rate limiting)
- Перегрузке БД (неоптимальный пул соединений)
- Медленным запросам из-за отсутствия индексов

**Рекомендуется немедленно:**
1. ✅ Добавить rate limiting
2. ✅ Настроить пул соединений БД
3. ✅ Добавить индексы в БД (isActive, restaurantId+isAvailable)
4. ✅ Добавить мониторинг производительности

После этих изменений приложение сможет стабильно обрабатывать **200-300 одновременных запросов** без риска падения.
