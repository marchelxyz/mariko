# Анализ производительности приложения

## Текущее состояние

### Backend (Express.js + TypeORM + PostgreSQL)
- **Фреймворк**: Express.js 4.18.2
- **ORM**: TypeORM 0.3.17
- **База данных**: PostgreSQL
- **Деплой**: Railway (один инстанс)
- **Rate Limiting**: ❌ Отсутствует
- **Кэширование**: ❌ Отсутствует
- **Пул соединений БД**: Используются дефолтные настройки TypeORM (10 соединений)

### Frontend (Next.js)
- **Фреймворк**: Next.js 14.0.4
- **Деплой**: Vercel (Serverless Functions)
- **SSR**: Включен

## Оценка пропускной способности

### Вариант 1: Базовый план (Hobby/Starter)

#### 1. Backend (Railway Starter)
**Оценка: 50-200 одновременных запросов**

Ограничения:
- **Один инстанс Node.js**: Express может обрабатывать ~1000-5000 запросов/сек на мощном сервере, но Railway на базовом плане ограничивает ресурсы
- **Пул соединений БД**: TypeORM по умолчанию использует 10 соединений. При превышении запросы будут ждать освобождения соединения
- **Память**: Railway на базовом плане предоставляет ограниченную память (обычно 512MB-1GB)
- **CPU**: Ограниченные ресурсы CPU на базовом плане Railway

**Реальные цифры:**
- Легкие запросы (GET /api/restaurants): ~100-200 req/s
- Средние запросы (GET /api/menu/:id): ~50-100 req/s
- Тяжелые запросы (POST /api/auth/telegram с созданием пользователя): ~20-50 req/s

#### 2. База данных (PostgreSQL на Railway Starter)
**Оценка: 50-100 одновременных соединений**

Ограничения:
- Railway PostgreSQL на базовом плане обычно ограничивает до 100 одновременных соединений
- TypeORM пул из 10 соединений - это узкое место при высокой нагрузке
- Нет индексов на часто используемых полях (требуется проверка)

#### 3. Frontend (Vercel Hobby)
**Оценка: Практически неограниченно (Serverless)**

Vercel использует Serverless Functions, которые автоматически масштабируются:
- Каждый запрос обрабатывается отдельным инстансом
- Ограничение только по таймауту (10 секунд для Hobby плана)
- Может обрабатывать тысячи одновременных запросов

---

### Вариант 2: Pro план (Railway Pro + Vercel Pro) ⭐

#### 1. Backend (Railway Pro)
**Оценка: 500-2000+ одновременных запросов (с масштабированием)**

Преимущества Pro плана:
- **Память**: 2-8GB RAM (вместо 512MB-1GB)
- **CPU**: Значительно больше CPU ресурсов (2-4 vCPU)
- **Горизонтальное масштабирование**: Возможность запуска нескольких инстансов
- **Автомасштабирование**: Railway может автоматически масштабировать инстансы при нагрузке
- **Больше bandwidth**: Выше лимиты на трафик

**Реальные цифры с одним инстансом Pro:**
- Легкие запросы (GET /api/restaurants): ~500-1000 req/s
- Средние запросы (GET /api/menu/:id): ~300-600 req/s
- Тяжелые запросы (POST /api/auth/telegram): ~100-200 req/s

**С масштабированием (2-4 инстанса):**
- Легкие запросы: ~2000-4000 req/s
- Средние запросы: ~1200-2400 req/s
- Тяжелые запросы: ~400-800 req/s

#### 2. База данных (PostgreSQL на Railway Pro)
**Оценка: 200-500 одновременных соединений**

Преимущества Pro плана:
- **Больше соединений**: До 200-500 одновременных соединений (вместо 100)
- **Больше памяти БД**: 2-8GB RAM для БД
- **Лучшая производительность**: Более мощные инстансы БД
- **Резервные копии**: Автоматические бэкапы включены

**Рекомендация**: Увеличить пул TypeORM до 50-100 соединений (вместо 10)

#### 3. Frontend (Vercel Pro)
**Оценка: Практически неограниченно (Serverless)**

Преимущества Pro плана:
- **Function Execution Time**: До 60 секунд (вместо 10)
- **Больше bandwidth**: Выше лимиты на трафик
- **Приоритетная поддержка**: Быстрее решение проблем
- **Аналитика**: Расширенная аналитика производительности

Vercel Serverless Functions автоматически масштабируются:
- Может обрабатывать десятки тысяч одновременных запросов
- Каждый запрос обрабатывается отдельным инстансом
- Ограничение только по таймауту (60 секунд для Pro)

## Критические проблемы

### 1. ❌ Отсутствие Rate Limiting
**Риск**: Приложение уязвимо к DDoS атакам и злоупотреблению

**Последствия:**
- Один пользователь может отправить тысячи запросов и перегрузить сервер
- Возможна атака на эндпоинты аутентификации
- Исчерпание пула соединений БД

### 2. ⚠️ Неоптимальный пул соединений БД
**Проблема**: TypeORM использует дефолтные 10 соединений

**Последствия:**
- При 11+ одновременных запросах к БД один запрос будет ждать
- Увеличение времени отклика при высокой нагрузке

### 3. ⚠️ Отсутствие кэширования
**Проблема**: Каждый запрос идет в БД

**Последствия:**
- Избыточная нагрузка на БД для статических данных (меню, рестораны)
- Медленные ответы при повторных запросах

### 4. ⚠️ Нет мониторинга производительности
**Проблема**: Нет метрик для отслеживания производительности

**Последствия:**
- Невозможно определить узкие места
- Нет предупреждений о перегрузке

## Рекомендации по улучшению

### Приоритет 1: Критично (защита от падения)

#### 1. Добавить Rate Limiting
```bash
npm install express-rate-limit
```

**Ожидаемый эффект**: Защита от перегрузки, возможность обработать 100-200 req/s стабильно

#### 2. Настроить пул соединений БД
Увеличить пул до 20-30 соединений (в зависимости от лимитов Railway PostgreSQL)

**Ожидаемый эффект**: Увеличение пропускной способности до 200-300 одновременных запросов

#### 3. Добавить graceful degradation
При перегрузке возвращать 503 Service Unavailable вместо падения

**Ожидаемый эффект**: Приложение не падает, а корректно обрабатывает перегрузку

### Приоритет 2: Важно (улучшение производительности)

#### 4. Добавить кэширование для статических данных
- Redis для кэширования меню и ресторанов
- TTL: 5-15 минут для меню, 1 час для ресторанов

**Ожидаемый эффект**: Увеличение пропускной способности до 500-1000 req/s для кэшируемых эндпоинтов

#### 5. Оптимизировать запросы к БД
- Добавить индексы на часто используемые поля
- Использовать `select` для загрузки только нужных полей
- Избегать N+1 запросов

**Ожидаемый эффект**: Уменьшение времени ответа на 30-50%

#### 6. Добавить мониторинг
- Логирование времени выполнения запросов
- Метрики через Prometheus или аналоги
- Алерты при превышении порогов

### Приоритет 3: Желательно (масштабирование)

#### 7. Горизонтальное масштабирование
- Запуск нескольких инстансов через PM2 или Railway scaling
- Использование load balancer

**Ожидаемый эффект**: Линейное увеличение пропускной способности (2 инстанса = 2x производительность)

#### 8. Оптимизация базы данных
- Connection pooling на уровне БД (PgBouncer)
- Репликация для чтения
- Партиционирование больших таблиц

## Итоговая оценка пропускной способности

### Базовый план (Starter/Hobby)

#### Текущее состояние (без оптимизаций)
- **Одновременных запросов**: 50-100
- **Запросов в секунду**: 50-200 req/s
- **Риск падения**: Высокий при нагрузке >100 одновременных запросов

#### После оптимизаций Приоритета 1
- **Одновременных запросов**: 200-300
- **Запросов в секунду**: 200-400 req/s
- **Риск падения**: Средний при нагрузке >300 одновременных запросов

#### После всех оптимизаций
- **Одновременных запросов**: 500-1000+
- **Запросов в секунду**: 1000-2000+ req/s (для кэшируемых эндпоинтов)
- **Риск падения**: Низкий при правильной настройке

---

### Pro план (Railway Pro + Vercel Pro) ⭐

#### Текущее состояние (без оптимизаций, один инстанс)
- **Одновременных запросов**: 200-500
- **Запросов в секунду**: 300-1000 req/s
- **Риск падения**: Средний при нагрузке >500 одновременных запросов
- **Ограничение**: Пул БД из 10 соединений остается узким местом

#### После оптимизаций Приоритета 1 (один инстанс)
- **Одновременных запросов**: 500-1000
- **Запросов в секунду**: 800-2000 req/s
- **Риск падения**: Низкий при нагрузке до 1000 одновременных запросов
- **Улучшения**: Rate limiting + пул БД 50-100 соединений + индексы

#### С масштабированием (2-4 инстанса) + все оптимизации
- **Одновременных запросов**: 2000-5000+
- **Запросов в секунду**: 3000-8000+ req/s
- **Риск падения**: Очень низкий при правильной настройке
- **Требования**: 
  - Rate limiting настроен
  - Пул БД увеличен до 50-100 соединений
  - Индексы добавлены
  - Кэширование включено (Redis)
  - Мониторинг настроен

#### С кэшированием (Redis) + масштабирование
- **Одновременных запросов**: 5000-10000+
- **Запросов в секунду**: 10000-20000+ req/s (для кэшируемых эндпоинтов)
- **Риск падения**: Минимальный
- **Примечание**: Для кэшируемых эндпоинтов (меню, рестораны) производительность значительно выше

## Конкретные проблемы в коде

### Отсутствие индексов в БД

#### 1. Restaurant.isActive
**Проблема**: В `restaurants.ts` запрос фильтрует по `isActive: true`, но нет индекса
```typescript
// Текущий код делает полное сканирование таблицы
const restaurants = await restaurantRepository.find({
  where: { isActive: true },
});
```

**Решение**: Добавить индекс
```typescript
@Column({ default: true })
@Index()
isActive!: boolean;
```

#### 2. MenuItem.restaurantId и MenuItem.isAvailable
**Проблема**: В `menu.ts` запрос фильтрует по `restaurantId` и `isAvailable`, но нет составного индекса
```typescript
// Текущий код может быть медленным при большом количестве меню
const menuItems = await menuItemRepository.find({
  where: { restaurantId, isAvailable: true },
});
```

**Решение**: Добавить составной индекс
```typescript
@Entity('menu_items')
@Index(['restaurantId', 'isAvailable'])
export class MenuItem {
  // ...
}
```

**Ожидаемый эффект**: Ускорение запросов меню на 50-90% при большом количестве записей

## Выводы

### Базовый план (Starter/Hobby)

**Текущая пропускная способность: 50-100 одновременных запросов**

Приложение может обработать умеренную нагрузку, но уязвимо к:
- Внезапным всплескам трафика
- DDoS атакам (нет rate limiting)
- Перегрузке БД (неоптимальный пул соединений)
- Медленным запросам из-за отсутствия индексов

**Рекомендуется немедленно:**
1. ✅ Добавить rate limiting
2. ✅ Настроить пул соединений БД (до 20-30)
3. ✅ Добавить индексы в БД (isActive, restaurantId+isAvailable)
4. ✅ Добавить мониторинг производительности

После этих изменений приложение сможет стабильно обрабатывать **200-300 одновременных запросов** без риска падения.

---

### Pro план (Railway Pro + Vercel Pro) ⭐

**Текущая пропускная способность: 200-500 одновременных запросов (один инстанс)**

С Pro планом у вас значительно больше возможностей:

**Без оптимизаций:**
- ✅ **200-500 одновременных запросов** (в 4-5 раз больше базового плана)
- ✅ **300-1000 req/s** благодаря большим ресурсам CPU/RAM
- ⚠️ Все еще ограничено пулом БД из 10 соединений

**После базовых оптимизаций (rate limiting + пул БД + индексы):**
- ✅ **500-1000 одновременных запросов** (один инстанс)
- ✅ **800-2000 req/s**
- ✅ Стабильная работа без падений

**С масштабированием (2-4 инстанса) + все оптимизации:**
- ✅ **2000-5000+ одновременных запросов**
- ✅ **3000-8000+ req/s**
- ✅ Готовность к высоким нагрузкам

**С кэшированием (Redis) + масштабирование:**
- ✅ **5000-10000+ одновременных запросов**
- ✅ **10000-20000+ req/s** для кэшируемых эндпоинтов
- ✅ Профессиональный уровень производительности

**Рекомендации для Pro плана:**
1. ✅ **Критично**: Добавить rate limiting (защита от злоупотребления ресурсами)
2. ✅ **Критично**: Увеличить пул БД до 50-100 соединений (используйте возможности Pro плана!)
3. ✅ **Важно**: Добавить индексы в БД
4. ✅ **Важно**: Настроить автомасштабирование на Railway (2-4 инстанса при нагрузке)
5. ✅ **Рекомендуется**: Добавить Redis для кэширования (значительно увеличит производительность)
6. ✅ **Рекомендуется**: Настроить мониторинг и алерты

**Итог для Pro плана:**
С правильной настройкой и оптимизациями ваше приложение сможет обрабатывать **2000-5000+ одновременных запросов** и **3000-8000+ req/s**, что достаточно для большинства коммерческих приложений среднего и крупного масштаба.
